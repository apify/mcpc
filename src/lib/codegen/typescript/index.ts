/**
 * TypeScript code generator for MCP servers
 *
 * Generates a TypeScript project with typed stubs for interacting with MCP servers.
 */

import { Tool, Prompt, Resource } from '@modelcontextprotocol/sdk/types.js';
import {
  jsonSchemaToTs,
  toPascalCase,
  toCamelCase,
  deduplicateNames,
  JsonSchema,
} from './json-schema-to-ts.js';

export interface McpServerData {
  serverName: string;
  serverVersion?: string;
  tools: Tool[];
  prompts: Prompt[];
  resources: Resource[];
  hasLogging: boolean;
}

export interface GeneratedFile {
  path: string;
  content: string;
}

/**
 * Generate all TypeScript files for an MCP server.
 */
export function generateTypeScriptProject(data: McpServerData): GeneratedFile[] {
  const files: GeneratedFile[] = [];

  // Generate schemas.ts (stored JSON schemas for validation)
  files.push({
    path: 'src/schemas.ts',
    content: generateSchemasFile(data),
  });

  // Generate types.ts
  files.push({
    path: 'src/types.ts',
    content: generateTypesFile(data),
  });

  // Generate client.ts
  files.push({
    path: 'src/client.ts',
    content: generateClientFile(data),
  });

  // Generate tools.ts (if server has tools)
  if (data.tools.length > 0) {
    files.push({
      path: 'src/tools.ts',
      content: generateToolsFile(data.tools),
    });
  }

  // Generate prompts.ts (if server has prompts)
  if (data.prompts.length > 0) {
    files.push({
      path: 'src/prompts.ts',
      content: generatePromptsFile(data.prompts),
    });
  }

  // Generate resources.ts (if server has resources)
  if (data.resources.length > 0) {
    files.push({
      path: 'src/resources.ts',
      content: generateResourcesFile(data.resources),
    });
  }

  // Generate index.ts
  files.push({
    path: 'src/index.ts',
    content: generateIndexFile(data),
  });

  // Generate package.json
  files.push({
    path: 'package.json',
    content: generatePackageJson(data),
  });

  // Generate tsconfig.json
  files.push({
    path: 'tsconfig.json',
    content: generateTsConfig(),
  });

  return files;
}

/**
 * Generate schemas.ts with stored JSON schemas for validation.
 */
function generateSchemasFile(data: McpServerData): string {
  const lines: string[] = [];

  lines.push('/**');
  lines.push(` * Stored JSON schemas for ${data.serverName} MCP server`);
  lines.push(' *');
  lines.push(' * These schemas are captured at generation time and can be used to validate');
  lines.push(' * that the MCP server interface has not changed.');
  lines.push(' *');
  lines.push(' * DO NOT EDIT - This file is auto-generated by mcpc codegen');
  lines.push(' */');
  lines.push('');

  // Export tool schemas
  lines.push('export const toolSchemas: Record<string, { inputSchema: unknown; outputSchema?: unknown }> = {');
  for (const tool of data.tools) {
    lines.push(`  '${tool.name}': {`);
    lines.push(`    inputSchema: ${JSON.stringify(tool.inputSchema, null, 2).split('\n').join('\n    ')},`);
    if (tool.outputSchema) {
      lines.push(`    outputSchema: ${JSON.stringify(tool.outputSchema, null, 2).split('\n').join('\n    ')},`);
    }
    lines.push('  },');
  }
  lines.push('};');
  lines.push('');

  // Export prompt schemas
  lines.push('export const promptSchemas: Record<string, { arguments: Array<{ name: string; required?: boolean }> }> = {');
  for (const prompt of data.prompts) {
    const args = (prompt.arguments || []).map((arg) => ({
      name: arg.name,
      required: arg.required,
    }));
    lines.push(`  '${prompt.name}': {`);
    lines.push(`    arguments: ${JSON.stringify(args)},`);
    lines.push('  },');
  }
  lines.push('};');
  lines.push('');

  // Export generation metadata
  lines.push('export const schemaMetadata = {');
  lines.push(`  generatedAt: '${new Date().toISOString()}',`);
  lines.push(`  serverName: '${data.serverName}',`);
  if (data.serverVersion) {
    lines.push(`  serverVersion: '${data.serverVersion}',`);
  }
  lines.push(`  toolCount: ${data.tools.length},`);
  lines.push(`  promptCount: ${data.prompts.length},`);
  lines.push(`  resourceCount: ${data.resources.length},`);
  lines.push('};');
  lines.push('');

  return lines.join('\n');
}

/**
 * Generate types.ts with all TypeScript interfaces from tool/prompt schemas.
 */
function generateTypesFile(data: McpServerData): string {
  const lines: string[] = [];

  lines.push('/**');
  lines.push(` * Generated TypeScript types for ${data.serverName} MCP server`);
  lines.push(' * ');
  lines.push(' * DO NOT EDIT - This file is auto-generated by mcpc codegen');
  lines.push(' */');
  lines.push('');

  // Generate tool input/output types
  for (const tool of data.tools) {
    const baseName = toPascalCase(tool.name);

    // Input type
    if (tool.inputSchema) {
      const inputResult = jsonSchemaToTs(
        tool.inputSchema as JsonSchema,
        `${baseName}Input`,
      );
      for (const decl of inputResult.declarations) {
        lines.push(decl);
        lines.push('');
      }
    }

    // Output type (if present)
    if (tool.outputSchema) {
      const outputResult = jsonSchemaToTs(
        tool.outputSchema as JsonSchema,
        `${baseName}Output`,
      );
      for (const decl of outputResult.declarations) {
        lines.push(decl);
        lines.push('');
      }
    }
  }

  // Generate prompt argument types
  for (const prompt of data.prompts) {
    if (prompt.arguments && prompt.arguments.length > 0) {
      const baseName = toPascalCase(prompt.name);
      lines.push(`export interface ${baseName}Args {`);
      for (const arg of prompt.arguments) {
        if (arg.description) {
          lines.push('  /**');
          lines.push(`   * ${arg.description}`);
          lines.push('   */');
        }
        const optional = arg.required ? '' : '?';
        lines.push(`  ${arg.name}${optional}: string;`);
      }
      lines.push('}');
      lines.push('');
    }
  }

  // Add MCP result types that might be needed
  lines.push('// MCP response types');
  lines.push('');
  lines.push('export interface CallToolResult {');
  lines.push('  content: Array<{');
  lines.push('    type: string;');
  lines.push('    text?: string;');
  lines.push('    data?: string;');
  lines.push('    mimeType?: string;');
  lines.push('  }>;');
  lines.push('  isError?: boolean;');
  lines.push('}');
  lines.push('');

  lines.push('export interface GetPromptResult {');
  lines.push('  description?: string;');
  lines.push('  messages: Array<{');
  lines.push('    role: "user" | "assistant";');
  lines.push('    content: {');
  lines.push('      type: string;');
  lines.push('      text?: string;');
  lines.push('    };');
  lines.push('  }>;');
  lines.push('}');
  lines.push('');

  lines.push('export interface ReadResourceResult {');
  lines.push('  contents: Array<{');
  lines.push('    uri: string;');
  lines.push('    mimeType?: string;');
  lines.push('    text?: string;');
  lines.push('    blob?: string;');
  lines.push('  }>;');
  lines.push('}');
  lines.push('');

  lines.push('export type LoggingLevel = "debug" | "info" | "notice" | "warning" | "error" | "critical" | "alert" | "emergency";');
  lines.push('');

  return lines.join('\n');
}

/**
 * Generate client.ts with McpcClient class.
 */
function generateClientFile(data: McpServerData): string {
  return `/**
 * MCP client for ${data.serverName}
 *
 * DO NOT EDIT - This file is auto-generated by mcpc codegen
 */

import { spawn } from 'child_process';
import type { LoggingLevel, CallToolResult, GetPromptResult, ReadResourceResult } from './types.js';
import { toolSchemas } from './schemas.js';

export type SchemaMode = 'strict' | 'compatible' | 'ignore';

export interface McpcClientOptions {
  /** Target: session name (@name), server URL, or config entry */
  target: string;
  /** Path to MCP config file (for config entry targets) */
  configFile?: string;
  /** OAuth profile name */
  profile?: string;
  /** Additional HTTP headers */
  headers?: string[];
  /** Request timeout in seconds */
  timeout?: number;
  /**
   * Schema validation mode:
   * - 'strict': Validate that server schema matches exactly
   * - 'compatible': Allow compatible changes (new optional fields)
   * - 'ignore': Skip validation (default)
   */
  schemaMode?: SchemaMode;
}

export class McpcError extends Error {
  constructor(
    message: string,
    public code: number,
    public stderr: string,
  ) {
    super(message);
    this.name = 'McpcError';
  }
}

export class SchemaValidationError extends Error {
  constructor(
    message: string,
    public toolName: string,
    public expectedSchema: unknown,
    public actualSchema: unknown,
  ) {
    super(message);
    this.name = 'SchemaValidationError';
  }
}

export class McpcClient {
  constructor(private options: McpcClientOptions) {}

  /**
   * Call a tool with the given arguments.
   * If schemaMode is set, validates the tool's schema before calling.
   */
  async callTool<TInput, TOutput = CallToolResult>(
    name: string,
    args: TInput,
  ): Promise<TOutput> {
    // Validate schema if requested
    if (this.options.schemaMode && this.options.schemaMode !== 'ignore') {
      await this.validateToolSchema(name);
    }
    return this.exec(['tools-call', name], args);
  }

  /**
   * Get a prompt with the given arguments.
   */
  async getPrompt(name: string, args?: Record<string, string>): Promise<GetPromptResult> {
    return this.exec(['prompts-get', name], args);
  }

  /**
   * Read a resource by URI.
   */
  async readResource(uri: string): Promise<ReadResourceResult> {
    return this.exec(['resources-read', uri]);
  }

  /**
   * List all available resources.
   */
  async listResources(): Promise<Array<{ uri: string; name?: string; description?: string; mimeType?: string }>> {
    return this.exec(['resources-list']);
  }

  /**
   * List resource templates.
   */
  async listResourceTemplates(): Promise<Array<{ uriTemplate: string; name?: string; description?: string; mimeType?: string }>> {
    return this.exec(['resources-templates-list']);
  }

  /**
   * Ping the server and return round-trip time.
   */
  async ping(): Promise<{ roundTripMs: number }> {
    return this.exec(['ping']);
  }

  /**
   * Set the server's logging level.
   */
  async setLoggingLevel(level: LoggingLevel): Promise<void> {
    await this.exec(['logging-set-level', level]);
  }

  /**
   * Validate that a tool's current schema matches the stored schema.
   */
  private async validateToolSchema(name: string): Promise<void> {
    const storedSchema = toolSchemas[name];
    if (!storedSchema) {
      throw new SchemaValidationError(
        \`Tool '\${name}' not found in stored schemas. Was this stub generated for a different server?\`,
        name,
        undefined,
        undefined,
      );
    }

    // Fetch current schema from server
    const currentTool = await this.exec<{ inputSchema: unknown; outputSchema?: unknown }>(['tools-get', name]);

    // Compare schemas
    const mode = this.options.schemaMode || 'compatible';
    const diff = this.compareSchemas(storedSchema.inputSchema, currentTool.inputSchema, mode);

    if (diff) {
      throw new SchemaValidationError(
        \`Tool '\${name}' schema has changed: \${diff}\`,
        name,
        storedSchema.inputSchema,
        currentTool.inputSchema,
      );
    }
  }

  /**
   * Compare two schemas and return a description of differences, or null if compatible.
   */
  private compareSchemas(expected: unknown, actual: unknown, mode: SchemaMode): string | null {
    const expectedStr = JSON.stringify(expected, null, 2);
    const actualStr = JSON.stringify(actual, null, 2);

    if (mode === 'strict') {
      // Strict mode: schemas must be identical
      if (expectedStr !== actualStr) {
        return 'Schemas do not match exactly (strict mode)';
      }
    } else {
      // Compatible mode: check for breaking changes
      // New optional fields are OK, removed required fields are breaking
      const expectedObj = expected as Record<string, unknown>;
      const actualObj = actual as Record<string, unknown>;

      if (expectedObj && actualObj && typeof expectedObj === 'object' && typeof actualObj === 'object') {
        const expectedProps = (expectedObj.properties || {}) as Record<string, unknown>;
        const actualProps = (actualObj.properties || {}) as Record<string, unknown>;
        const expectedRequired = new Set((expectedObj.required || []) as string[]);

        // Check if any required fields were removed
        for (const [propName] of Object.entries(expectedProps)) {
          if (expectedRequired.has(propName) && !(propName in actualProps)) {
            return \`Required property '\${propName}' was removed\`;
          }
        }

        // Check if types changed for existing properties
        for (const [propName, expectedProp] of Object.entries(expectedProps)) {
          if (propName in actualProps) {
            const expectedType = (expectedProp as Record<string, unknown>)?.type;
            const actualType = (actualProps[propName] as Record<string, unknown>)?.type;
            if (expectedType !== actualType) {
              return \`Property '\${propName}' type changed from '\${expectedType}' to '\${actualType}'\`;
            }
          }
        }
      }
    }

    return null;
  }

  /**
   * Execute an mcpc command and return parsed JSON result.
   */
  private async exec<T>(command: string[], input?: unknown): Promise<T> {
    const args = this.buildArgs(command);

    return new Promise((resolve, reject) => {
      const proc = spawn('mcpc', args, {
        stdio: ['pipe', 'pipe', 'pipe'],
      });

      let stdout = '';
      let stderr = '';

      proc.stdout.on('data', (data: Buffer) => {
        stdout += data.toString();
      });

      proc.stderr.on('data', (data: Buffer) => {
        stderr += data.toString();
      });

      proc.on('close', (code: number | null) => {
        if (code !== 0) {
          // Try to parse error message from stderr or stdout
          let message = stderr.trim() || stdout.trim() || \`mcpc exited with code \${code}\`;
          // Extract just the error message if possible
          const match = message.match(/(?:Error|error):\\s*(.+?)(?:\\n|$)/);
          if (match) {
            message = match[1];
          }
          reject(new McpcError(message, code || 1, stderr));
          return;
        }

        try {
          const result = JSON.parse(stdout);
          resolve(result);
        } catch {
          reject(new McpcError(\`Failed to parse mcpc output: \${stdout}\`, 1, stderr));
        }
      });

      proc.on('error', (err: Error) => {
        reject(new McpcError(\`Failed to spawn mcpc: \${err.message}\`, 1, ''));
      });

      // Send input via stdin if provided
      if (input !== undefined) {
        proc.stdin.write(JSON.stringify(input));
      }
      proc.stdin.end();
    });
  }

  /**
   * Build mcpc command arguments.
   */
  private buildArgs(command: string[]): string[] {
    const args: string[] = ['--json'];

    if (this.options.configFile) {
      args.push('--config', this.options.configFile);
    }

    if (this.options.profile) {
      args.push('--profile', this.options.profile);
    }

    if (this.options.headers) {
      for (const header of this.options.headers) {
        args.push('--header', header);
      }
    }

    if (this.options.timeout) {
      args.push('--timeout', String(this.options.timeout));
    }

    args.push(this.options.target);
    args.push(...command);

    return args;
  }
}
`;
}

/**
 * Generate tools.ts with typed tool functions.
 */
function generateToolsFile(tools: Tool[]): string {
  const lines: string[] = [];

  // Deduplicate function names (e.g., "search-actors" and "search_actors" both become "searchActors")
  const funcNameMap = deduplicateNames(tools.map((t) => t.name));

  lines.push('/**');
  lines.push(' * Typed tool functions');
  lines.push(' *');
  lines.push(' * DO NOT EDIT - This file is auto-generated by mcpc codegen');
  lines.push(' */');
  lines.push('');
  lines.push("import type { McpcClient } from './client.js';");

  // Collect all type imports
  const typeImports: string[] = [];
  for (const tool of tools) {
    const baseName = toPascalCase(tool.name);
    if (tool.inputSchema && hasProperties(tool.inputSchema as JsonSchema)) {
      typeImports.push(`${baseName}Input`);
    }
    if (tool.outputSchema) {
      typeImports.push(`${baseName}Output`);
    }
  }
  typeImports.push('CallToolResult');

  if (typeImports.length > 0) {
    lines.push(`import type { ${typeImports.join(', ')} } from './types.js';`);
  }

  lines.push('');
  lines.push('export function createTools(client: McpcClient) {');
  lines.push('  return {');

  for (const tool of tools) {
    const funcName = funcNameMap.get(tool.name) || toCamelCase(tool.name);
    const baseName = toPascalCase(tool.name);

    // JSDoc
    lines.push('    /**');
    if (tool.description) {
      lines.push(`     * ${escapeJsDoc(tool.description)}`);
    } else {
      lines.push(`     * Call the ${tool.name} tool`);
    }
    lines.push('     */');

    // Determine input type
    const hasInput = tool.inputSchema && hasProperties(tool.inputSchema as JsonSchema);
    const inputType = hasInput ? `${baseName}Input` : 'Record<string, unknown>';
    // Type annotation must come before default value: (args: Type = {})
    const inputParam = hasInput ? `args: ${inputType}` : `args: ${inputType} = {}`;

    // Determine output type
    const outputType = tool.outputSchema ? `${baseName}Output` : 'CallToolResult';

    lines.push(`    ${funcName}: (${inputParam}): Promise<${outputType}> =>`);
    lines.push(`      client.callTool('${tool.name}', args),`);
    lines.push('');
  }

  lines.push('  };');
  lines.push('}');
  lines.push('');

  return lines.join('\n');
}

/**
 * Generate prompts.ts with typed prompt functions.
 */
function generatePromptsFile(prompts: Prompt[]): string {
  const lines: string[] = [];

  // Deduplicate function names
  const funcNameMap = deduplicateNames(prompts.map((p) => p.name));

  lines.push('/**');
  lines.push(' * Typed prompt functions');
  lines.push(' *');
  lines.push(' * DO NOT EDIT - This file is auto-generated by mcpc codegen');
  lines.push(' */');
  lines.push('');
  lines.push("import type { McpcClient } from './client.js';");

  // Collect type imports
  const typeImports: string[] = ['GetPromptResult'];
  for (const prompt of prompts) {
    if (prompt.arguments && prompt.arguments.length > 0) {
      typeImports.push(`${toPascalCase(prompt.name)}Args`);
    }
  }

  lines.push(`import type { ${typeImports.join(', ')} } from './types.js';`);
  lines.push('');
  lines.push('export function createPrompts(client: McpcClient) {');
  lines.push('  return {');

  for (const prompt of prompts) {
    const funcName = funcNameMap.get(prompt.name) || toCamelCase(prompt.name);
    const baseName = toPascalCase(prompt.name);

    // JSDoc
    lines.push('    /**');
    if (prompt.description) {
      lines.push(`     * ${escapeJsDoc(prompt.description)}`);
    } else {
      lines.push(`     * Get the ${prompt.name} prompt`);
    }
    lines.push('     */');

    // Determine args type
    const hasArgs = prompt.arguments && prompt.arguments.length > 0;
    const argsType = hasArgs ? `${baseName}Args` : 'Record<string, string>';
    // Type annotation must come before default value: (args: Type = {})
    const argsParam = hasArgs ? `args: ${argsType}` : `args: ${argsType} = {}`;

    lines.push(`    ${funcName}: (${argsParam}): Promise<GetPromptResult> =>`);
    lines.push(`      client.getPrompt('${prompt.name}', args),`);
    lines.push('');
  }

  lines.push('  };');
  lines.push('}');
  lines.push('');

  return lines.join('\n');
}

/**
 * Generate resources.ts with resource helper functions.
 */
function generateResourcesFile(resources: Resource[]): string {
  const lines: string[] = [];

  lines.push('/**');
  lines.push(' * Resource helper functions');
  lines.push(' *');
  lines.push(' * DO NOT EDIT - This file is auto-generated by mcpc codegen');
  lines.push(' */');
  lines.push('');
  lines.push("import type { McpcClient } from './client.js';");
  lines.push("import type { ReadResourceResult } from './types.js';");
  lines.push('');
  lines.push('export function createResources(client: McpcClient) {');
  lines.push('  return {');
  lines.push('    /** List all available resources */');
  lines.push('    list: () => client.listResources(),');
  lines.push('');
  lines.push('    /** Read a resource by URI */');
  lines.push('    read: (uri: string): Promise<ReadResourceResult> => client.readResource(uri),');
  lines.push('');
  lines.push('    /** List resource templates */');
  lines.push('    listTemplates: () => client.listResourceTemplates(),');
  lines.push('');

  // Generate typed accessors for known resources
  for (const resource of resources) {
    if (resource.name) {
      const funcName = toCamelCase(resource.name);
      lines.push('    /**');
      if (resource.description) {
        lines.push(`     * ${escapeJsDoc(resource.description)}`);
      } else {
        lines.push(`     * Read the ${resource.name} resource`);
      }
      lines.push(`     * URI: ${resource.uri}`);
      lines.push('     */');
      lines.push(`    ${funcName}: (): Promise<ReadResourceResult> => client.readResource('${resource.uri}'),`);
      lines.push('');
    }
  }

  lines.push('  };');
  lines.push('}');
  lines.push('');

  return lines.join('\n');
}

/**
 * Generate index.ts that re-exports everything.
 */
function generateIndexFile(data: McpServerData): string {
  const lines: string[] = [];

  lines.push('/**');
  lines.push(` * TypeScript client for ${data.serverName} MCP server`);
  lines.push(' *');
  lines.push(' * DO NOT EDIT - This file is auto-generated by mcpc codegen');
  lines.push(' */');
  lines.push('');
  lines.push("export { McpcClient, McpcError, SchemaValidationError } from './client.js';");
  lines.push("export type { McpcClientOptions, SchemaMode } from './client.js';");
  lines.push("export { toolSchemas, promptSchemas, schemaMetadata } from './schemas.js';");
  lines.push("export * from './types.js';");

  if (data.tools.length > 0) {
    lines.push("export { createTools } from './tools.js';");
  }
  if (data.prompts.length > 0) {
    lines.push("export { createPrompts } from './prompts.js';");
  }
  if (data.resources.length > 0) {
    lines.push("export { createResources } from './resources.js';");
  }

  lines.push('');
  lines.push('/*');
  lines.push(' * Usage example:');
  lines.push(' *');
  lines.push(" * import { McpcClient, createTools } from './';");
  lines.push(' *');
  lines.push(` * const client = new McpcClient({ target: '@your-session' });`);

  const firstTool = data.tools[0];
  if (firstTool) {
    lines.push(' * const tools = createTools(client);');
    lines.push(' *');
    const funcName = toCamelCase(firstTool.name);
    lines.push(` * const result = await tools.${funcName}({ ... });`);
  }

  lines.push(' */');
  lines.push('');

  return lines.join('\n');
}

/**
 * Generate package.json for the stub project.
 */
function generatePackageJson(data: McpServerData): string {
  const pkg = {
    name: `${data.serverName.toLowerCase().replace(/[^a-z0-9-]/g, '-')}-mcp-client`,
    version: '1.0.0',
    description: `TypeScript client for ${data.serverName} MCP server`,
    type: 'module',
    main: 'dist/index.js',
    types: 'dist/index.d.ts',
    scripts: {
      build: 'tsc',
      clean: 'rm -rf dist',
    },
    devDependencies: {
      '@types/node': '^22.0.0',
      typescript: '^5.0.0',
    },
    engines: {
      node: '>=18.0.0',
    },
  };

  return JSON.stringify(pkg, null, 2) + '\n';
}

/**
 * Generate tsconfig.json for the stub project.
 */
function generateTsConfig(): string {
  const config = {
    compilerOptions: {
      target: 'ES2022',
      module: 'NodeNext',
      moduleResolution: 'NodeNext',
      declaration: true,
      declarationMap: true,
      sourceMap: true,
      outDir: './dist',
      rootDir: './src',
      strict: true,
      esModuleInterop: true,
      skipLibCheck: true,
      forceConsistentCasingInFileNames: true,
    },
    include: ['src/**/*'],
    exclude: ['node_modules', 'dist'],
  };

  return JSON.stringify(config, null, 2) + '\n';
}

/**
 * Check if a schema has properties defined.
 */
function hasProperties(schema: JsonSchema): boolean {
  return !!(schema.properties && Object.keys(schema.properties).length > 0);
}

/**
 * Escape text for use in JSDoc comments.
 * Prevents comment termination by replacing `*​/` with `*\​/`.
 */
function escapeJsDoc(text: string): string {
  return text.replace(/\*\//g, '*\\/');
}
